1. Data Structure

Game:
		t:        //----------轮数
		Pr:       //----------第t轮真实市场价格
		Pr_next:  //----------第t+1轮的真实市场价格
		A:        //----------第t轮做决策时的决策积累量，extended demand
		Pt:       //----------第t轮交易价格 the tranction price
		Pt_next:  //----------第t+1轮的交易价格
		state:    //----------t时刻市场状态，one of the 2m strings of the m most recent outcomes of the sign of price changes.
		
		
		price_series:  //-----历史价格序列，如过去100轮价格
		
		agents[];  //agents
		
		m;			//记忆长度
		s;			//策越个数
		n;			//agents个数
		
		PRICE_LENGTH; //100
		GAMA:     //----------the sensitivity of price increment. 
		BETA:     //----------the market impact factor.
		
Agents:
		t:        //----------轮数 
		k;        /*----------头寸，头寸提供了一个简单的模拟真实市场中有限财富的影响----------*/
		Max_k:    //----------最大头寸，最大头寸起限制头寸过大的作用，当头寸的绝对值到达最大头寸的限制时，头寸的绝对值不再增加，模型的一个结果是财富具有可加性，而不是可乘性。
		cash:     //----------现金量
		wealth:   //----------真实财富
		
		strategy[];//策越
		
		a:        //----------决定，trading decision. 
		s:        //----------策越个数
		BUY;	  // +1
		SELL;     // -1
		HOLD; 	  // 0

Strategy:
		t:         //---------轮数
		m:         //---------记忆长度
		outcome[]; //---策越决定，length = 2^m, value = -1,0, or +1.
		v_a:       //---------策略的虚拟决策
		v_k:       //---------策略的虚拟头寸
		Max_k:     //---------最大头寸
		v_wealth:  //---------策略的虚拟财富
		
2
程序实现流程:
(1)初始化
Game的初始化：
   0.获取传入参数s.m.n
   1.初始化t=0, Pr=0,Pr_next=0,A=0,,Pt_next=0
   2.初始化n个agents
   3.载入price_series
   4.根据price_series初始化state.
   
Agents的初始化：
   0.获取传入参数s,m
   1.初始化k=0,cash=0,wealth=0,a=0;
   2.初始化s个策越
   
Strategy的初始化：
   0.获取传入参数m
   1.初始化v_k=0,v_wealth=0.
   2.初始化2^m个策略决定outcome[2^m];
   
(2)第T步计算（模拟模型交易）
   1. Game:  根据T轮的历史价格序列price_series中最近m轮价格波动计算市场状态state.
   2. Strategy:每个Strategy根据state计算得虚拟决策v_a.
   3. Agent: 每个agent根据state从s个策略中选出最优策越，Agents的决策即为最优策略的决策Agent.a = best{his Strategy.v_a}.（注意，这里有个时间先后顺序的问题，agent这时对市场做了决策并提交了订单，但交易价格还未产生，财富不能更新，头寸k也不能更新，故不更新轮数t）。
   4. Game:  获取真实人的决策，再根据Agent的a计算策略积累量A.
   5. Game:  根据A和Pr计算第T+1轮的真实市场价格Pr_next.
   6. Game:  根据第T轮真实市场价格Pr和第T+1轮真实市场价格Pr_next计算第T轮的交易价格Pt.
   7. Strategy:第T轮的交易价格Pt产生后, Strategy根据此时的虚拟财富v_wealth和头寸v_k计算出strategy的虚拟财富: Strategy.v_wealth = Strategy.v_wealth + Strategy.v_k *(Pt_next-Pt).
   8. Strategy:更新strategy的头寸: Strategy.v_k = max{-Max_k, min{K, Strategy.v_k+Strategy.a}},并更新Strategy的时刻t至T+1时刻.
   9. Agent: 第T轮的交易价格Pt产生后，Agent根据此时的财富wealth和头寸k就能计算出agent第T+1轮的财富：Agent.wealth = Agent.wealth + Agent.k *(Pt_next-Pt).
   10.Agent: 更新agent的头寸: Agent.v_k = max{-Max_k, min{K, Agent.v_k + Agent.a}},并更新Agent的时刻t至T+1时刻.
   11.Game:  第T至T+1轮交易完成，把Game的时间更新到T+1,令Pr = Pr_next, Pr_next=0.将Pr写入price_series中，等待下一轮的进行。 
   12.Game:  计算真实人的财富，输出Game这轮的信息。
